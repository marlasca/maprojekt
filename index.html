<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Mapa b√°sico con Leaflet</title>

  <!-- Estilos y scripts de Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

  <!-- Leaflet-providersESP para capas IGN -->
  <script src="https://cdn.jsdelivr.net/gh/dieghernan/leaflet-providersESP/dist/leaflet-providersESP.min.js"></script>

  <!-- Leaflet.draw para dibujar en el mapa -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css" />
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <!-- Leaflet GPX y Omnivore -->
  <script src="https://api.mapbox.com/mapbox.js/plugins/leaflet-omnivore/v0.3.4/leaflet-omnivore.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-gpx/gpx.min.js"></script>

  <!-- JSZip para manejar KMZ -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

  <!-- Estilos propios -->
  <link rel="stylesheet" href="styles.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"/>

</head>

<body>
  <!-- Contenedor del mapa -->
  <div id="map"></div>

  <script>
    // --- Capas base ---
    var osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '¬© OpenStreetMap'
    });

    const ignBase = L.tileLayer.providerESP('IGNBase.Todo');  
    const mtn = L.tileLayer.providerESP('MTN');               
    const pnoaProv = L.tileLayer.providerESP('PNOA');         

    // --- Overlays ---
    const nombres = L.tileLayer.providerESP('NombresGeograficos'); 
    const curvas = L.tileLayer.providerESP('MDT.CurvasNivel');    

    // --- Inicializar mapa ---
    var map = L.map('map', {
      center: [43.150931, -4.813221],
      zoom: 13,
      layers: [osm]
    });

    // --- Control de capas ---
    const baseMaps = {
      'OpenStreetMap': osm,
      'IGN Base (callejero)': ignBase,
      'MTN (Mapa Raster)': mtn,
      'IGN Ortofoto': pnoaProv
    };
    const overlays = {
      'Nombres geogr√°ficos': nombres,
      'Curvas de nivel': curvas
    };
    L.control.layers(baseMaps, overlays, { collapsed: false }).addTo(map);

    // --- Control de color para dibujos ---
    let currentColor = "#3388ff"; 
    const ColorControl = L.Control.extend({
      onAdd: function(map) {
        const div = L.DomUtil.create('div', 'color-control');
        div.innerHTML =
          '<label><strong>Color dibujo:</strong></label><br>' +
          '<input type="color" id="colorPicker" value="' + currentColor + '">';
        L.DomEvent.disableClickPropagation(div);
        return div;
      }
    });
    map.addControl(new ColorControl({ position: 'topright' }));

    // --- Leaflet.draw ---
    const drawnItems = new L.FeatureGroup();
    map.addLayer(drawnItems);

    function createDrawControl(color) {
      return new L.Control.Draw({
        draw: {
          polyline: { shapeOptions: { color: color, weight: 3 } },
          polygon: { shapeOptions: { color: color, weight: 2, fillColor: color, fillOpacity: 0.4 } },
          rectangle: { shapeOptions: { color: color, weight: 2, fillOpacity: 0.4 } },
          circle: { shapeOptions: { color: color, weight: 2, fillOpacity: 0.4 } },
          circlemarker: { shapeOptions: { color: color, weight: 2, fillColor: color, fillOpacity: 0.6 } },
          marker: {icon: createColoredMarker(color)}
        },
        edit: { featureGroup: drawnItems }
      });
    }

    let drawControl = createDrawControl(currentColor);
    map.addControl(drawControl);

    document.getElementById('colorPicker').addEventListener('input', function(e) {
      currentColor = e.target.value;
      map.removeControl(drawControl);
      drawControl = createDrawControl(currentColor);
      map.addControl(drawControl);
    });

	
	map.on(L.Draw.Event.CREATED, function (e) {
	  const layer = e.layer;

	  if (e.layerType === "polygon" || e.layerType === "rectangle" || e.layerType === "polyline") {
		layer.setStyle({
		  color: currentColor,
		  fillColor: currentColor,
		  fillOpacity: 0.4
		});
	  }

	  if (e.layerType === "circlemarker") {
		// Mantener el color de los circlemarkers
		layer.setStyle({
		  color: currentColor,
		  fillColor: currentColor,
		  fillOpacity: 0.6
		});
	  }
if (e.layerType === "marker") {
    layer.feature = layer.feature || { properties: {} };

    if (currentIconKey && currentIconKey !== "pin") {
        // Iconos especiales: flag, house, truck, etc.
        layer.setIcon(customIcons[currentIconKey]);
        layer.feature.properties.iconKey = currentIconKey;
    } else {
        // Marker normal coloreable con SVG din√°mico
        const svgIcon = L.divIcon({
            className: "",
            html: `
              <svg xmlns="http://www.w3.org/2000/svg" width="25" height="41" viewBox="0 0 25 41">
                <path d="M12.5 0C5.6 0 0 5.6 0 12.5c0 8.8 12.5 28.5 12.5 28.5S25 21.3 25 12.5C25 5.6 19.4 0 12.5 0z"
                  fill="${currentColor}" stroke="black" stroke-width="1"/>
                <circle cx="12.5" cy="12.5" r="5" fill="white"/>
              </svg>
            `,
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [0, -35]
        });
        layer.setIcon(svgIcon);
        layer.feature.properties["marker-color"] = currentColor;
    }
}
	  drawnItems.addLayer(layer);
	});



    // --- Control de coordenadas ---
    const CoordsControl = L.Control.extend({
      onAdd: function(map) {
        const div = L.DomUtil.create('div', 'coords-control');
        div.innerHTML =
          '<div><strong>Coordenadas:</strong></div>' +
          '<label>Lat: <input type="text" id="latBox" readonly></label><br>' +
          '<label>Lng: <input type="text" id="lngBox" readonly></label>';
        L.DomEvent.disableClickPropagation(div);
        L.DomEvent.disableScrollPropagation(div);
        return div;
      }
    });
    map.addControl(new CoordsControl({ position: 'topright' }));

    // --- Waypoints ---
    const waypoints = L.layerGroup().addTo(map);
    map.on('click', function(e) {
      const lat = e.latlng.lat.toFixed(6);
      const lng = e.latlng.lng.toFixed(6);
      document.getElementById('latBox').value = lat;
      document.getElementById('lngBox').value = lng;
      waypoints.clearLayers();
      L.marker([lat, lng]).addTo(waypoints);
    });

    // --- Grupo para capas cargadas ---
    const loadedLayers = L.layerGroup().addTo(map);

    // --- Listado de capas ---
    const LayersListControl = L.Control.extend({
      onAdd: function(map) {
        const div = L.DomUtil.create('div', 'layers-list-control');
        div.innerHTML = `<strong>Capas cargadas:</strong><br><div id="layersList"></div>`;
        L.DomEvent.disableClickPropagation(div);
        return div;
      }
    });
    map.addControl(new LayersListControl({ position: 'topright' }));

    function addLayerToList(layer, name) {
      const listDiv = document.getElementById('layersList');
      const id = "layer-" + Date.now();
      let displayName = name.length > 20 ? name.substring(0, 20) + '‚Ä¶' : name;

      const item = document.createElement("div");
      item.style.display = "flex";
      item.style.justifyContent = "space-between";
      item.style.alignItems = "center";
      item.style.marginBottom = "4px";

      item.innerHTML = `
        <label style="flex:1; cursor:pointer;">
          <input type="checkbox" id="${id}" checked>
          ${displayName}
        </label>
        <button class="remove-btn" title="Eliminar capa">‚úñ</button>
      `;
      listDiv.appendChild(item);

      document.getElementById(id).addEventListener("change", function(e) {
        if (e.target.checked) {
          loadedLayers.addLayer(layer);
        } else {
          loadedLayers.removeLayer(layer);
        }
      });

      item.querySelector(".remove-btn").addEventListener("click", function() {
        loadedLayers.removeLayer(layer);
        listDiv.removeChild(item);
      });
    }



    // --- Crear marcadores de color personalizado ---
    function createColoredMarker(color) {
      return L.divIcon({
        className: "",
        html: `
          <svg xmlns="http://www.w3.org/2000/svg" width="25" height="41" viewBox="0 0 25 41">
            <path d="M12.5 0C5.6 0 0 5.6 0 12.5c0 8.8 12.5 28.5 12.5 28.5S25 21.3 25 12.5C25 5.6 19.4 0 12.5 0z"
              fill="${color}" stroke="black" stroke-width="1"/>
            <circle cx="12.5" cy="12.5" r="5" fill="white"/>
          </svg>
        `,
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [0, -35]
      });
    }

    // --- Exportar dibujo a GeoJSON (c√≠rculos como pol√≠gonos, circlemarkers preservados) ---
	function circleToPolygon(circle, points = 60) {
	  const coords = [];
	  const center = circle.getLatLng();
	  const radius = circle.getRadius();
	  const earthRadius = 6378137; // radio de la Tierra en metros

	  for (let i = 0; i < points; i++) {
		const angle = (i * 2 * Math.PI) / points;
		const dx = (radius / earthRadius) * Math.cos(angle);
		const dy = (radius / earthRadius) * Math.sin(angle);

		// desplazamiento en lat/lng
		const lat = center.lat + (dy * 180) / Math.PI;
		const lng = center.lng + (dx * 180) / Math.PI / Math.cos(center.lat * Math.PI / 180);

		coords.push([lng, lat]);
	  }
	  coords.push(coords[0]); // cerrar pol√≠gono

	  return {
		type: "Feature",
		properties: { type: "circle" },
		geometry: { type: "Polygon", coordinates: [coords] }
	  };
	}

function exportGeoJSON() {
  const features = [];

  drawnItems.eachLayer(layer => {
    let f;

    if (layer instanceof L.Circle) {
      f = circleToPolygon(layer);
      f.properties = f.properties || {};
      if (layer.options) {
        if (layer.options.color)       f.properties.color = layer.options.color;
        if (layer.options.fillColor)   f.properties.fillColor = layer.options.fillColor;
        if (layer.options.fillOpacity !== undefined) f.properties.fillOpacity = layer.options.fillOpacity;
        if (layer.options.weight !== undefined)      f.properties.weight = layer.options.weight;
        if (layer.options.opacity !== undefined)     f.properties.opacity = layer.options.opacity;
      }
      features.push(f);

    } else if (layer instanceof L.CircleMarker) {
      f = layer.toGeoJSON();
      f.properties = f.properties || {};
      f.properties["marker-type"] = "circlemarker";
      if (layer.options) {
        if (layer.options.radius !== undefined)      f.properties.radius = layer.options.radius;
        if (layer.options.color)       f.properties.color = layer.options.color;
        if (layer.options.fillColor)   f.properties.fillColor = layer.options.fillColor;
        if (layer.options.fillOpacity !== undefined) f.properties.fillOpacity = layer.options.fillOpacity;
        if (layer.options.weight !== undefined)      f.properties.weight = layer.options.weight;
        if (layer.options.opacity !== undefined)     f.properties.opacity = layer.options.opacity;
      }
      features.push(f);

    } else if (layer instanceof L.Marker) {
	  f = layer.toGeoJSON();
	  f.type = "Feature"; 
	  f.properties = f.properties || {};
	  if (layer.options.icon?.options?.key) {
		f.properties.iconKey = layer.options.icon.options.key;   // icono de tu lista
	  }
	  if (layer.options.icon?.options?.markerColor) {
		f.properties["marker-color"] = layer.options.icon.options.markerColor; // color simple
	  }
	  features.push(f);

    } else if (layer instanceof L.Path) {
      // Cubre: Polyline, Polygon, Rectangle (todo lo que ‚Äúpinta‚Äù salvo Circle/CircleMarker)
      f = layer.toGeoJSON();
      f.properties = f.properties || {};
      const opt = layer.options || {};
      if (opt.color)       f.properties.color = opt.color;
      if (opt.fillColor)   f.properties.fillColor = opt.fillColor;
      if (opt.fillOpacity !== undefined) f.properties.fillOpacity = opt.fillOpacity;
      if (opt.weight !== undefined)      f.properties.weight = opt.weight;
      if (opt.opacity !== undefined)     f.properties.opacity = opt.opacity;
      features.push(f);

    } else {
      features.push(layer.toGeoJSON());
    }
  });

  return { type: "FeatureCollection", features };
}






    function download(data, filename, type) {
      const file = new Blob([data], {type: type});
      const a = document.createElement("a");
      const url = URL.createObjectURL(file);
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => {
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
      }, 0);
    }

const ExportControl = L.Control.extend({
  onAdd: function(map) {
    const div = L.DomUtil.create("div", "leaflet-control leaflet-bar");
    const btn = L.DomUtil.create("a", "", div);
    btn.innerHTML = "üíæ";
    btn.href = "#";
    btn.title = "Exportar todo a GeoJSON";

    L.DomEvent.on(btn, "click", function(e) {
      L.DomEvent.preventDefault(e);

      // 1) Exportar dibujos con estilos usando exportGeoJSON()
      const drawn = exportGeoJSON();   // <- aqu√≠ ya se guardan color, fillColor, fillOpacity, etc.
      const features = [...drawn.features];

      // 2) Exportar capas importadas (tal cual vienen del fichero)
      loadedLayers.eachLayer(layer => {
        if (typeof layer.toGeoJSON === "function") {
          const gj = layer.toGeoJSON();
          if (!gj) return;
          if (gj.type === "FeatureCollection" && Array.isArray(gj.features)) {
            features.push(...gj.features);
          } else {
            features.push(gj);
          }
        }
      });

      // 3) Unir todo en un FeatureCollection
      const geojson = { type: "FeatureCollection", features };
      const data = JSON.stringify(geojson, null, 2);

      // Descargar archivo
      const blob = new Blob([data], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "mapa.geojson";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    });

    return div;
  }
});

    map.addControl(new ExportControl({ position: "topleft" }));
	
// Control de importar archivos (GPX, GeoJSON, KML, KMZ) sobre el mapa
const ImportControl = L.Control.extend({
  onAdd: function(map) {
    const div = L.DomUtil.create("div", "leaflet-control leaflet-bar");

    // Bot√≥n visible üìÇ
    const btn = L.DomUtil.create("a", "", div);
    btn.innerHTML = "üìÇ";
    btn.href = "#";
    btn.title = "Cargar archivo (GPX, GeoJSON, KML, KMZ)";

    // Input file invisible cubriendo el bot√≥n
    const input = L.DomUtil.create("input", "", div);
    input.type = "file";
    input.accept = ".gpx,.geojson,.json,.kml,.kmz";
    Object.assign(input.style, {
      position: "absolute",
      inset: "0",
      opacity: 0,
      cursor: "pointer"
    });

    // Manejador de carga (misma l√≥gica que ya ten√≠as)
    input.addEventListener("change", async function(e) {
      const file = e.target.files[0];
      if (!file) return;

      const name = file.name.toLowerCase();

      try {
        if (name.endsWith(".kmz")) {
          const zip = await JSZip.loadAsync(file);
          const kmlFile = Object.keys(zip.files).find(f => f.toLowerCase().endsWith(".kml"));
          if (!kmlFile) { alert("KMZ no contiene KML"); input.value = ""; return; }
          const kmlText = await zip.file(kmlFile).async("text");
          omnivore.kml.parse(kmlText).on("ready", function() {
            map.fitBounds(this.getBounds());
            const geojson = this.toGeoJSON();
            const layer = processGeoJSON(geojson);
            addLayerToList(layer, file.name);
          });

        } else if (name.endsWith(".kml")) {
          const text = await file.text();
          omnivore.kml.parse(text).on("ready", function() {
            map.fitBounds(this.getBounds());
            const geojson = this.toGeoJSON();
            const layer = processGeoJSON(geojson);
            addLayerToList(layer, file.name);
          });

        } else if (name.endsWith(".gpx")) {
          const text = await file.text();
          new L.GPX(text, { async: true }).on("loaded", function(evt) {
            map.fitBounds(evt.target.getBounds());
            const geojson = evt.target.toGeoJSON();
            const layer = processGeoJSON(geojson);
            addLayerToList(layer, file.name);
          });

        } else if (name.endsWith(".geojson") || name.endsWith(".json")) {
          const text = await file.text();
          const data = JSON.parse(text);
          const layer = processGeoJSON(data);
          if (layer.getBounds && layer.getBounds().isValid()) {
            map.fitBounds(layer.getBounds());
          }
          addLayerToList(layer, file.name);

        } else {
          alert("Formato no soportado. Usa GPX, KML/KMZ o GeoJSON");
        }
      } catch (err) {
        console.error(err);
        alert("No se pudo cargar el archivo: " + err.message);
      } finally {
        input.value = ""; // reset para poder reusar el mismo archivo
      }
    });

    // Evitar scroll/clicks ‚Äúraros‚Äù en el control
    L.DomEvent.disableClickPropagation(div);
    L.DomEvent.disableScrollPropagation(div);

    return div;
  }
});

// A√±adirlo al mapa
map.addControl(new ImportControl({ position: "topleft" }));

	
	const customIcons = {
	  pin: L.divIcon({
		html: '<i class="fas fa-map-marker-alt" style="font-size:24px; color:red;"></i>',
		iconSize: [24, 24],
		className: 'custom-div-icon'
	  }),
	  flag: L.divIcon({
		html: '<i class="fas fa-flag" style="font-size:24px; color:blue;"></i>',
		iconSize: [24, 24],
		className: 'custom-div-icon'
	  }),
	  house: L.divIcon({
		html: '<i class="fas fa-house" style="font-size:24px; color:green;"></i>',
		iconSize: [24, 24],
		className: 'custom-div-icon'
	  }),
	  truck: L.divIcon({
		html: '<i class="fas fa-truck" style="font-size:24px; color:orange;"></i>',
		iconSize: [24, 24],
		className: 'custom-div-icon'
	  }),
	  person: L.divIcon({
		html: '<i class="fas fa-person" style="font-size:24px; color:black;"></i>',
		iconSize: [24, 24],
		className: 'custom-div-icon'
	  }),
	  helicopter: L.divIcon({
		html: '<i class="fas fa-helicopter" style="font-size:24px; color:purple;"></i>',
		iconSize: [24, 24],
		className: 'custom-div-icon'
	  }),
	  fire: L.divIcon({
		html: '<i class="fas fa-fire" style="font-size:24px; color:red;"></i>',
		iconSize: [24, 24],
		className: 'custom-div-icon'
	  }),
	  cross: L.divIcon({
		html: '<i class="fas fa-xmark" style="font-size:24px; color:black;"></i>',
		iconSize: [24, 24],
		className: 'custom-div-icon'
	  }),
	  car: L.divIcon({
		html: '<i class="fas fa-car" style="font-size:24px; color:blue;"></i>',
		iconSize: [24, 24],
		className: 'custom-div-icon'
	  }),
	  ship: L.divIcon({
		html: '<i class="fas fa-ship" style="font-size:24px; color:navy;"></i>',
		iconSize: [24, 24],
		className: 'custom-div-icon'
	  })
	};
	
	
	// === CONTROL DE ICONOS PERSONALIZADOS ===
	L.Control.IconSelector = L.Control.extend({
	  onAdd: function(map) {
		const div = L.DomUtil.create('div', 'info legend');
		div.innerHTML = `
		  <label><strong>Icono marcador:</strong></label><br>
		  <select id="iconSelector">
			<option value="pin">üìç Pin</option>
			<option value="flag">üö© Bandera</option>
			<option value="house">üè† Casa</option>
			<option value="truck">üöö Cami√≥n</option>
			<option value="person">üßç Persona</option>
			<option value="helicopter">üöÅ Helic√≥ptero</option>
			<option value="fire">üî• Fuego</option>
			<option value="cross">‚ùå X</option>
			<option value="car">üöó Coche</option>
			<option value="ship">‚õ¥ Barco</option>
		  </select>
		`;
		L.DomEvent.disableClickPropagation(div);
		return div;
	  }
	});

	// A√±adir control al mapa
	map.addControl(new L.Control.IconSelector({ position: 'topright' }));

	// Guardar icono seleccionado
	let currentIconKey = "pin";
	document.getElementById("iconSelector").addEventListener("change", function(e) {
	  currentIconKey = e.target.value;
	});

	
	function processGeoJSON(data) {
	  const geoLayer = L.geoJSON(data, {
		pointToLayer: function (feature, latlng) {
		  if (feature.properties["marker-type"] === "circlemarker") {
			return L.circleMarker(latlng, {
			  radius: feature.properties.radius || 10,
			  color: feature.properties.color || "#3388ff",
			  fillColor: feature.properties.fillColor || feature.properties.color || "#3388ff",
			  fillOpacity: feature.properties.fillOpacity ?? 0.6
			});
		  } else if (feature.properties.iconKey) {
			// Usar icono de tu lista
			return L.marker(latlng, {
			  icon: customIcons[feature.properties.iconKey] || customIcons["pin"]
			});
		  } else if (feature.properties["marker-color"]) {
			return L.marker(latlng, {
			  icon: L.divIcon({
				className: "",
				html: `<svg width="25" height="41" viewBox="0 0 25 41">
						 <path d="M12.5 0C5.6 0 0 5.6 0 12.5c0 8.8 12.5 28.5 12.5 28.5S25 21.3 25 12.5C25 5.6 19.4 0 12.5 0z"
							   fill="${feature.properties["marker-color"]}" stroke="black" stroke-width="1"/>
						 <circle cx="12.5" cy="12.5" r="5" fill="white"/>
					   </svg>`,
				iconSize: [25, 41],
				iconAnchor: [12, 41],
				popupAnchor: [0, -35]
			  })
			});
		  } else {
			// Marker normal sin nada especial
			return L.marker(latlng);
		  }
		},

		onEachFeature: function (feature, layer) {
		  // Estilos solo si el layer soporta setStyle
		  if (layer.setStyle && feature.properties) {
			const style = {};
			if (feature.properties.color) style.color = feature.properties.color;
			if (feature.properties.fillColor) style.fillColor = feature.properties.fillColor;
			if (feature.properties.fillOpacity !== undefined) style.fillOpacity = feature.properties.fillOpacity;
			layer.setStyle(style);
		  }

		  // A√±adimos al drawnItems para que sea editable
		  drawnItems.addLayer(layer);
		}
	  }).addTo(loadedLayers);

	  return geoLayer;
	}

  </script>
</body>
</html>
